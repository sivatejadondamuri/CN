11. Write a Program to implement Distance Vector Routing algorithm by obtaining routing table at each node.



Aim:
To write a program that implements the Distance Vector Routing algorithm to compute the routing tables for each node in a subnet with given link delays.

Theory:
Distance Vector Routing is a dynamic routing algorithm where each router maintains a vector (table) of the minimum distance to every other router. Routers periodically share their distance vectors with neighbors. Using the Bellmanâ€“Ford equation, each router updates its routing table based on the shortest known distance. The process continues until no more updates occur.

C Program:

#include <stdio.h>

struct node {
    int dist[10];
    int nextHop[10];
} rt[10];

int main() {
    int cost[10][10];
    int nodes, i, j, k, updated;

    printf("Enter number of nodes: ");
    scanf("%d", &nodes);

    printf("Enter cost adjacency matrix (999 for no link):\n");
    for(i = 0; i < nodes; i++)
        for(j = 0; j < nodes; j++)
            scanf("%d", &cost[i][j]);

    for(i = 0; i < nodes; i++) {
        for(j = 0; j < nodes; j++) {
            rt[i].dist[j] = cost[i][j];
            if(cost[i][j] != 999 && i != j)
                rt[i].nextHop[j] = j;
            else
                rt[i].nextHop[j] = -1;
        }
    }

    do {
        updated = 0;
        for(i = 0; i < nodes; i++) {
            for(j = 0; j < nodes; j++) {
                for(k = 0; k < nodes; k++) {
                    if(rt[i].dist[j] > cost[i][k] + rt[k].dist[j]) {
                        rt[i].dist[j] = cost[i][k] + rt[k].dist[j];
                        rt[i].nextHop[j] = k;
                        updated = 1;
                    }
                }
            }
        }
    } while(updated);

    for(i = 0; i < nodes; i++) {
        printf("\nRouting table for Node %d:\n", i);
        printf("Destination\tCost\tNext Hop\n");
        for(j = 0; j < nodes; j++) {
            printf("%d\t\t%d\t\t%d\n", j, rt[i].dist[j], rt[i].nextHop[j]);
        }
    }

    return 0;
}

Expected Output:

Enter number of nodes: 4
Enter cost adjacency matrix:
0 2 999 1
2 0 3 999
999 3 0 1
1 999 1 0

Routing table for Node 0:
Destination    Cost    Next Hop
0              0        -1
1              2         1
2              2         3
3              1         3

Routing table for Node 1:
Destination    Cost    Next Hop
0              2         0
1              0        -1
2              3         2
3              4         2

Routing table for Node 2:
Destination    Cost    Next Hop
0              2         3
1              3         1
2              0        -1
3              1         3

Routing table for Node 3:
Destination    Cost    Next Hop
0              1         0
1              4         2
2              1         2
3              0        -1